<ID, include>
<RELOP, <>
<ID, bits>
<MULOP, />
<ID, stdc>
<INCOP, ++>
<ID, h>
<RELOP, >>
<ID, using>
<ID, namespace>
<ID, std>
<SEMICOLON, ;>
<ID, class>
<ID, Node>
<LCURL, {>
<ID, public>
<INT, int>
<ID, value>
<SEMICOLON, ;>
<ID, Node>
<MULOP, *>
<ID, parent>
<SEMICOLON, ;>
<ID, vector>
<RELOP, <>
<ID, Node>
<MULOP, *>
<RELOP, >>
<ID, children>
<SEMICOLON, ;>
<INT, int>
<ID, degree>
<SEMICOLON, ;>
<ID, bool>
<ID, marked>
<SEMICOLON, ;>
<ID, Node>
<LPAREN, (>
<INT, int>
<ID, val>
<RPAREN, )>
<LCURL, {>
<ID, value>
<ASSIGNOP, =>
<ID, val>
<SEMICOLON, ;>
<ID, parent>
<ASSIGNOP, =>
<ID, nullptr>
<SEMICOLON, ;>
<ID, children>
<ID, clear>
<LPAREN, (>
<RPAREN, )>
<SEMICOLON, ;>
<ID, degree>
<ASSIGNOP, =>
<CONST_INT, 0>
<SEMICOLON, ;>
<ID, marked>
<ASSIGNOP, =>
<ID, false>
<SEMICOLON, ;>
<RCURL, }>
<RCURL, }>
<SEMICOLON, ;>
<ID, class>
<ID, BinomialHeap>
<LCURL, {>
<ID, public>
<ID, vector>
<RELOP, <>
<ID, Node>
<MULOP, *>
<RELOP, >>
<ID, trees>
<SEMICOLON, ;>
<ID, Node>
<MULOP, *>
<ID, min_node>
<SEMICOLON, ;>
<INT, int>
<ID, count>
<SEMICOLON, ;>
<ID, BinomialHeap>
<LPAREN, (>
<RPAREN, )>
<LCURL, {>
<ID, min_node>
<ASSIGNOP, =>
<ID, nullptr>
<SEMICOLON, ;>
<ID, count>
<ASSIGNOP, =>
<CONST_INT, 0>
<SEMICOLON, ;>
<ID, trees>
<ID, clear>
<LPAREN, (>
<RPAREN, )>
<SEMICOLON, ;>
<RCURL, }>
<ID, bool>
<ID, is_empty>
<LPAREN, (>
<RPAREN, )>
<LCURL, {>
<RETURN, return>
<ID, min_node>
<RELOP, ==>
<ID, nullptr>
<SEMICOLON, ;>
<RCURL, }>
<VOID, void>
<ID, insert>
<LPAREN, (>
<INT, int>
<ID, value>
<RPAREN, )>
<LCURL, {>
<ID, Node>
<MULOP, *>
<ID, node>
<ASSIGNOP, =>
<ID, new>
<ID, Node>
<LPAREN, (>
<ID, value>
<RPAREN, )>
<SEMICOLON, ;>
<ID, BinomialHeap>
<ID, heap>
<SEMICOLON, ;>
<ID, heap>
<ID, trees>
<ID, push_back>
<LPAREN, (>
<ID, node>
<RPAREN, )>
<SEMICOLON, ;>
<ID, merge>
<LPAREN, (>
<ID, heap>
<RPAREN, )>
<SEMICOLON, ;>
<RCURL, }>
<INT, int>
<ID, get_min>
<LPAREN, (>
<RPAREN, )>
<LCURL, {>
<RETURN, return>
<ID, min_node>
<ADDOP, ->
<RELOP, >>
<ID, value>
<SEMICOLON, ;>
<RCURL, }>
<INT, int>
<ID, extract_min>
<LPAREN, (>
<RPAREN, )>
<LCURL, {>
<ID, Node>
<MULOP, *>
<ID, minNode>
<ASSIGNOP, =>
<ID, min_node>
<SEMICOLON, ;>
<ID, trees>
<ID, erase>
<LPAREN, (>
<ID, remove>
<LPAREN, (>
<ID, trees>
<ID, begin>
<LPAREN, (>
<RPAREN, )>
<COMMA, ,>
<ID, trees>
<ID, end>
<LPAREN, (>
<RPAREN, )>
<COMMA, ,>
<ID, minNode>
<RPAREN, )>
<COMMA, ,>
<ID, trees>
<ID, end>
<LPAREN, (>
<RPAREN, )>
<RPAREN, )>
<SEMICOLON, ;>
<ID, BinomialHeap>
<ID, heap>
<SEMICOLON, ;>
<ID, heap>
<ID, trees>
<ASSIGNOP, =>
<ID, minNode>
<ADDOP, ->
<RELOP, >>
<ID, children>
<SEMICOLON, ;>
<ID, merge>
<LPAREN, (>
<ID, heap>
<RPAREN, )>
<SEMICOLON, ;>
<ID, _find_min>
<LPAREN, (>
<RPAREN, )>
<SEMICOLON, ;>
<ID, count>
<ADDOP, ->
<ASSIGNOP, =>
<CONST_INT, 1>
<SEMICOLON, ;>
<RETURN, return>
<ID, minNode>
<ADDOP, ->
<RELOP, >>
<ID, value>
<SEMICOLON, ;>
<RCURL, }>
<VOID, void>
<ID, merge>
<LPAREN, (>
<ID, BinomialHeap>
<BITOP, &>
<ID, other_heap>
<RPAREN, )>
<LCURL, {>
<ID, trees>
<ID, insert>
<LPAREN, (>
<ID, trees>
<ID, end>
<LPAREN, (>
<RPAREN, )>
<COMMA, ,>
<ID, other_heap>
<ID, trees>
<ID, begin>
<LPAREN, (>
<RPAREN, )>
<COMMA, ,>
<ID, other_heap>
<ID, trees>
<ID, end>
<LPAREN, (>
<RPAREN, )>
<RPAREN, )>
<SEMICOLON, ;>
<ID, count>
<ADDOP, +>
<ASSIGNOP, =>
<ID, other_heap>
<ID, count>
<SEMICOLON, ;>
<ID, _find_min>
<LPAREN, (>
<RPAREN, )>
<SEMICOLON, ;>
<RCURL, }>
<VOID, void>
<ID, _find_min>
<LPAREN, (>
<RPAREN, )>
<LCURL, {>
<ID, min_node>
<ASSIGNOP, =>
<ID, nullptr>
<SEMICOLON, ;>
<FOR, for>
<LPAREN, (>
<ID, Node>
<MULOP, *>
<ID, tree>
<ID, trees>
<RPAREN, )>
<LCURL, {>
<IF, if>
<LPAREN, (>
<ID, min_node>
<RELOP, ==>
<ID, nullptr>
<LOGICOP, ||>
<ID, tree>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RELOP, <>
<ID, min_node>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RPAREN, )>
<LCURL, {>
<ID, min_node>
<ASSIGNOP, =>
<ID, tree>
<SEMICOLON, ;>
<RCURL, }>
<RCURL, }>
<RCURL, }>
<VOID, void>
<ID, decrease_key>
<LPAREN, (>
<ID, Node>
<MULOP, *>
<ID, node>
<COMMA, ,>
<INT, int>
<ID, new_value>
<RPAREN, )>
<LCURL, {>
<IF, if>
<LPAREN, (>
<ID, new_value>
<RELOP, >>
<ID, node>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RPAREN, )>
<LCURL, {>
<ID, throw>
<ID, invalid_argument>
<LPAREN, (>
<SINGLE LINE STRING, New value is greater than the current value>
<RPAREN, )>
<SEMICOLON, ;>
<RCURL, }>
<ID, node>
<ADDOP, ->
<RELOP, >>
<ID, value>
<ASSIGNOP, =>
<ID, new_value>
<SEMICOLON, ;>
<ID, _bubble_up>
<LPAREN, (>
<ID, node>
<RPAREN, )>
<SEMICOLON, ;>
<RCURL, }>
<VOID, void>
<ID, delete_node>
<LPAREN, (>
<ID, Node>
<MULOP, *>
<ID, node>
<RPAREN, )>
<LCURL, {>
<ID, decrease_key>
<LPAREN, (>
<ID, node>
<COMMA, ,>
<ID, INT_MIN>
<RPAREN, )>
<SEMICOLON, ;>
<ID, extract_min>
<LPAREN, (>
<RPAREN, )>
<SEMICOLON, ;>
<RCURL, }>
<VOID, void>
<ID, _bubble_up>
<LPAREN, (>
<ID, Node>
<MULOP, *>
<ID, node>
<RPAREN, )>
<LCURL, {>
<ID, Node>
<MULOP, *>
<ID, parent>
<ASSIGNOP, =>
<ID, node>
<ADDOP, ->
<RELOP, >>
<ID, parent>
<SEMICOLON, ;>
<WHILE, while>
<LPAREN, (>
<ID, parent>
<RELOP, !=>
<ID, nullptr>
<LOGICOP, &&>
<ID, node>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RELOP, <>
<ID, parent>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RPAREN, )>
<LCURL, {>
<ID, swap>
<LPAREN, (>
<ID, node>
<ADDOP, ->
<RELOP, >>
<ID, value>
<COMMA, ,>
<ID, parent>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RPAREN, )>
<SEMICOLON, ;>
<ID, node>
<ASSIGNOP, =>
<ID, parent>
<SEMICOLON, ;>
<ID, parent>
<ASSIGNOP, =>
<ID, node>
<ADDOP, ->
<RELOP, >>
<ID, parent>
<SEMICOLON, ;>
<RCURL, }>
<RCURL, }>
<VOID, void>
<ID, _link>
<LPAREN, (>
<ID, Node>
<MULOP, *>
<ID, tree1>
<COMMA, ,>
<ID, Node>
<MULOP, *>
<ID, tree2>
<RPAREN, )>
<LCURL, {>
<IF, if>
<LPAREN, (>
<ID, tree1>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RELOP, >>
<ID, tree2>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RPAREN, )>
<LCURL, {>
<ID, swap>
<LPAREN, (>
<ID, tree1>
<COMMA, ,>
<ID, tree2>
<RPAREN, )>
<SEMICOLON, ;>
<RCURL, }>
<ID, tree2>
<ADDOP, ->
<RELOP, >>
<ID, parent>
<ASSIGNOP, =>
<ID, tree1>
<SEMICOLON, ;>
<ID, tree1>
<ADDOP, ->
<RELOP, >>
<ID, children>
<ID, push_back>
<LPAREN, (>
<ID, tree2>
<RPAREN, )>
<SEMICOLON, ;>
<ID, tree1>
<ADDOP, ->
<RELOP, >>
<ID, degree>
<ADDOP, +>
<ASSIGNOP, =>
<CONST_INT, 1>
<SEMICOLON, ;>
<RCURL, }>
<VOID, void>
<ID, _consolidate>
<LPAREN, (>
<RPAREN, )>
<LCURL, {>
<INT, int>
<ID, max_degree>
<ASSIGNOP, =>
<ID, static_cast>
<RELOP, <>
<INT, int>
<RELOP, >>
<LPAREN, (>
<ID, floor>
<LPAREN, (>
<ID, log2>
<LPAREN, (>
<ID, count>
<RPAREN, )>
<RPAREN, )>
<RPAREN, )>
<ADDOP, +>
<CONST_INT, 1>
<SEMICOLON, ;>
<ID, vector>
<RELOP, <>
<ID, Node>
<MULOP, *>
<RELOP, >>
<ID, degree_to_tree>
<LPAREN, (>
<ID, max_degree>
<ADDOP, +>
<CONST_INT, 1>
<COMMA, ,>
<ID, nullptr>
<RPAREN, )>
<SEMICOLON, ;>
<WHILE, while>
<LPAREN, (>
<NOT, !>
<ID, trees>
<ID, empty>
<LPAREN, (>
<RPAREN, )>
<RPAREN, )>
<LCURL, {>
<ID, Node>
<MULOP, *>
<ID, current>
<ASSIGNOP, =>
<ID, trees>
<LSQUARE, [>
<CONST_INT, 0>
<RSQUARE, ]>
<SEMICOLON, ;>
<ID, trees>
<ID, erase>
<LPAREN, (>
<ID, trees>
<ID, begin>
<LPAREN, (>
<RPAREN, )>
<RPAREN, )>
<SEMICOLON, ;>
<INT, int>
<ID, degree>
<ASSIGNOP, =>
<ID, current>
<ADDOP, ->
<RELOP, >>
<ID, degree>
<SEMICOLON, ;>
<WHILE, while>
<LPAREN, (>
<ID, degree_to_tree>
<LSQUARE, [>
<ID, degree>
<RSQUARE, ]>
<RELOP, !=>
<ID, nullptr>
<RPAREN, )>
<LCURL, {>
<ID, Node>
<MULOP, *>
<ID, other>
<ASSIGNOP, =>
<ID, degree_to_tree>
<LSQUARE, [>
<ID, degree>
<RSQUARE, ]>
<SEMICOLON, ;>
<ID, degree_to_tree>
<LSQUARE, [>
<ID, degree>
<RSQUARE, ]>
<ASSIGNOP, =>
<ID, nullptr>
<SEMICOLON, ;>
<IF, if>
<LPAREN, (>
<ID, current>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RELOP, <>
<ID, other>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RPAREN, )>
<LCURL, {>
<ID, _link>
<LPAREN, (>
<ID, current>
<COMMA, ,>
<ID, other>
<RPAREN, )>
<SEMICOLON, ;>
<RCURL, }>
<ELSE, else>
<LCURL, {>
<ID, _link>
<LPAREN, (>
<ID, other>
<COMMA, ,>
<ID, current>
<RPAREN, )>
<SEMICOLON, ;>
<ID, current>
<ASSIGNOP, =>
<ID, other>
<SEMICOLON, ;>
<RCURL, }>
<ID, degree>
<INCOP, ++>
<SEMICOLON, ;>
<RCURL, }>
<ID, degree_to_tree>
<LSQUARE, [>
<ID, degree>
<RSQUARE, ]>
<ASSIGNOP, =>
<ID, current>
<SEMICOLON, ;>
<RCURL, }>
<ID, min_node>
<ASSIGNOP, =>
<ID, nullptr>
<SEMICOLON, ;>
<ID, trees>
<ID, clear>
<LPAREN, (>
<RPAREN, )>
<SEMICOLON, ;>
<FOR, for>
<LPAREN, (>
<ID, Node>
<MULOP, *>
<ID, tree>
<ID, degree_to_tree>
<RPAREN, )>
<LCURL, {>
<IF, if>
<LPAREN, (>
<ID, tree>
<RELOP, !=>
<ID, nullptr>
<RPAREN, )>
<LCURL, {>
<ID, trees>
<ID, push_back>
<LPAREN, (>
<ID, tree>
<RPAREN, )>
<SEMICOLON, ;>
<IF, if>
<LPAREN, (>
<ID, min_node>
<RELOP, ==>
<ID, nullptr>
<LOGICOP, ||>
<ID, tree>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RELOP, <>
<ID, min_node>
<ADDOP, ->
<RELOP, >>
<ID, value>
<RPAREN, )>
<LCURL, {>
<ID, min_node>
<ASSIGNOP, =>
<ID, tree>
<SEMICOLON, ;>
<RCURL, }>
<RCURL, }>
<RCURL, }>
<RCURL, }>
<INT, int>
<ID, size>
<LPAREN, (>
<RPAREN, )>
<LCURL, {>
<RETURN, return>
<ID, count>
<SEMICOLON, ;>
<RCURL, }>
<RCURL, }>
<SEMICOLON, ;>
